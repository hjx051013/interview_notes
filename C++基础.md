[来源](https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21)
# C++基础知识——基本语言(一)

**1. static关键字作用**
> 参见[C++中的static关键字的总结](https://www.cnblogs.com/beyondanytime/archive/2012/06/08/2542315.html)
- 全局静态变量。在全局变量前，加上关键字static。
    - 有以下特点
        - 该变量在全局数据区分配内存
        - 未经初始化的静态全局变量会被程序自动初始化为0
        - 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；
    - 有以下好处
        - 静态全局变量不能被其它文件所用
        - 其它文件中可以定义相同名字的变量，不会发生冲突；
    - 示例为
    ```
    #include <iostream.h>
    void fn();
    static int n; //定义静态全局变量
    void main()
    {
    　　n=20;
    　　cout<<n<<endl;
    　　fn();
    }

    void fn()
    {
    　　 n++;
    　　cout<<n<<endl;
    }
    ```
- 局部静态变量。在局部变量之前加上关键字static
    - 内存中的位置：静态存储区
    - 初始化：自动初始化为0
    - 作用域：作用域仍为局部作用域，但一直存在内存中。但再次调用函数时，该变量使用内存中值。
- 静态函数。函数返回类型前加static
    - 函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数冲突。
- 类的静态成员
    - 静态成员可以实现多个对象之间的数据共享。只存一处，供多个对象使用
- 类的静态函数
    - 调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);
    - 类的所有对象共用
    - 静态函数实现中不能调用费静态成员

**2. C++和C的区别**
- 设计思想上：
    - C++是面向对象的语言，而C是面向过程的结构化编程语言
- 语法上：
    - C++支持类，具有封装、继承和多态三种特性
    - C++相比C，增加多许多类型安全的功能，比如强制类型转换、
    - C++支持范式编程，比如模板类、函数模板等
    - C++支持函数和运算符重载
    - C++支持引用
    - C++提供new和delete来申请释放内存， 而c通过malloc, free
    - C++完全兼容C语法。
    - C使用namespace避免不同文件中的命名冲突
    - C++类支持virtual和friend函数
        - virtual函数是实现父类指针指向子类实例，通过父类指针调用虚函数时，实现多态的机制
        - 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。
        - friend function被定义在函数外，但是希望访问类的所有权限成员，可在类中将该函数声明为friend.friend函数/类不是类的成员


**3. C++中四种cast转换**
- C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast
    - const_cast。用于将const变量转为非const
    - static_cast。用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；
    - dynamic_cast。用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。向上转换：指的是子类向基类的转换；向下转换：指的是基类向子类的转换。它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。
    - reinterpret_cast。几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；

**4. C/C++ 中指针和引用的区别?**
- 指针有自己的一块空间，而引用只是一个别名；
- 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；
- 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；
- 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；
- 可以有const指针，但是没有const引用；
- 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；
- 指针可以有多级指针（**p），而引用至于一级；
- 指针和引用使用++运算符的意义不一样；指针++代表指向指针指向地址增加size,引用使用++代表引用对象自增
- 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。


** 5. c++中的smart pointer四个智能指针： shared_ptr,unique_ptr,weak_ptr,auto_ptr**
- 为何使用智能指针？
    - 避免指针申请的内存空间忘记释放，造成内存泄漏。智能指针就是一个类，当超出了类实例的作用域是，类实例会自动调用析构函数
- 四种智能指针类型
    - auto_ptr， c98使用， c11弃用
        - 采用所有权模式。
    
        ```
        //此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。
        auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
        auto_ptr<string> p2;
        p2 = p1; //auto_ptr不会报错.
        ```
        - unique_ptr（替换auto_ptr）。unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。且，临时右值赋值不会告警。
        ```
        unique_ptr<string> p3 (new string ("auto"));   //#4
        unique_ptr<string> p4；                       //#5
        p4 = p3;//此时会报错！！
        ```
        - shared_ptr。shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。
            - 成员函数：use_count 返回引用计数的个数；unique 返回是否是独占所有权( use_count 为 1)；swap 交换两个 shared_ptr 对象(即交换所拥有的对象)；reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少；get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的
        - weak_ptr。协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题。

**5. 数组和指针区别**
- 数组
    - 保存数据
    - 直接访问数据
    - 通常用于固定数目且数据类型相同的元素
    - 隐式的分配和删除
    - 自身即为数据名
- 指针
    - 保存数据的地址
    - 间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据
    - 通常用于动态的数据结构
    - 通过Malloc分配内存，free释放内存
    - 通常指向匿名数据，操作匿名函数

**6. 野指针是什么？**
- 野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针


**1. 为何基类的析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数**
- 将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

- C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

**2. 说明一下函数指针**
- 函数指针是指向函数的指针变量。C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样
- 调用函数和做函数的参数，比如回调函数
    ```
    char * fun(char * p)  {…}       // 函数fun
    char * (*pf)(char * p);             // 函数指针pf
    pf = fun;                        // 函数指针pf指向函数fun
    pf(p);                        // 通过函数指针pf调用函数fun
    ```

**3. 说明一下fork函数**
- 通过fork()可以创建一个和当前进程映像一样的进程可以通过
- 对于父进程，fork返回0；对于子进程，fork返回其pid；如果fork失败，返回负值
- 最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。即派生+执行
- 在fork进程时，现代的Unix系统例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。

**4. 说明一下C++中析构函数的作用**
- 与构造函数对应，当对象结束其生命周期如对象所在的函数已调用完毕，系统会自动执行析构函数。
- 析构函数名为~className(),它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。
- 编译器也总是会为我们合成一个析构函数, 这个析构函数什么也不做。因此，如果一个类中有指针，且在使用的过程中动态的申请了内存，就应该使用显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。

**5. 类静态函数和虚函数的区别**
> [C++虚函数表深入探索](https://cloud.tencent.com/developer/article/1599283)
- 静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存寻址开销

**6. 说明重载和覆盖**
- 重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中
    ```
    class A
    {
    public:
        void display(int a, int b ) 
        {
            printf("This is first /n");
        }
        void display(int a) 
        {
            printf("This is second/n"); 
        }
    };
    
    int main()
    {
        A a;
        a.display(5);
        return 0;
    }
    ```
- 覆盖，是指 派生类函数覆盖基类函数，只作用于派生类。作用范围不同(分别位于派生类与基类)，函数名字相同，参数相同，基类函数必须有virtual关键字。


**7. 说明strcpy和strlen**

**8. 说明虚函数和多态**

**9. 写个函数在main函数执行前先运行**

**10. 说明智能指针shared_ptr的实现**

**11. C++里是怎么定义常量的？常量存放在内存的哪个位置**

**12. 说明const关键字**


**1. 说一说隐式类型转换**
- 参考[彻底理解c++的隐式类型转换](https://www.cnblogs.com/apocelipes/p/14415033.html)

**2. 说说你了解的类型转换**
- 参考[https://blog.csdn.net/ydar95/article/details/69822540](https://blog.csdn.net/ydar95/article/details/69822540)
- 共四种
    - reinterpret_cast：可以用于任意类型的指针之间的转换，对转换的结果不做任何保证
    - dynamic_cast：这种其实也是不被推荐使用的，更多使用static_cast，dynamic本身只能用于存在虚函数的父子关系的强制类型转换，对于指针，转换失败则返回nullptr，对于引用，转换失败会抛出异常
    - const_cast：对于未定义const版本的成员函数，我们通常需要使用const_cast来去除const引用对象的const，完成函数调用。另外一种使用方式，结合static_cast，可以在非const版本的成员函数内添加const，调用完const版本的成员函数后，再使用const_cast去除const限定。
    - static_cast：完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换。

**3. C++函数栈空间的最大值**
- 默认是1M，不过可以调整
- 调整方法，
    - linux, 通过ulimit -s设置环境变量
    - windows通过ide可调

**4. extern“C”作用**
- C++调用C函数需要extern C，因为C语言没有函数重载。
- 参考[面试之C++：extern及extern “C”用法](https://developer.aliyun.com/article/338215)

**5. new/delete与malloc/free的区别是什么**
- new/delete是C++的关键字，而malloc/free是C语言的库函数
- malloc使用必须指明申请内存空间的大小， new不必
- 对于类类型的对象，malloc不会调用构造函数和析构函数, 而new会

**6. 说一下RTTI**
- 运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info
- 参考[RTTI (Run-time type Information) in C++](https://www.geeksforgeeks.org/g-fact-33/)

